-- Be warned, here be dragons

api = require "love-api.love_api"

-- A workaround, rename the event enum
for i, v in ipairs(api.modules) do
	if v.name == "event" then
		v.enums[1].name = "EventType"

		-- Weeeeeee
		for i, v in ipairs(v.functions) do
			for j, w in ipairs(v.variants or {}) do
				for k, x in ipairs(w.arguments or {}) do
					if x.type == "Event" then
						x.type = "EventType"
					end
				end
			end
		end
		break
	end
end

do -- THIS IS AN UGLY HACK
	local lovetypes =
	{
		Object = "love",
		Data = "love",
		Drawable = "love", -- wat?

		-- Generated by evil shell scripting, rather than hard labour
		-- for module in */; do module=${module%?}; for type in $module/*.hx; do type=$(basename $type .hx); printf '%s = "love.%s",\n' $type $module; done; done
		DistanceModel = "love.audio",
		Source = "love.audio",
		SourceType = "love.audio",
		TimeUnit = "love.audio",
		EventType = "love.event",
		BufferMode = "love.filesystem",
		FileData = "love.filesystem",
		FileDecoder = "love.filesystem",
		File = "love.filesystem",
		FileMode = "love.filesystem",
		AlignMode = "love.graphics",
		ArcType = "love.graphics",
		AreaSpreadDistribution = "love.graphics",
		BlendAlphaMode = "love.graphics",
		BlendMode = "love.graphics",
		CanvasFormat = "love.graphics",
		Canvas = "love.graphics",
		CompareMode = "love.graphics",
		DrawMode = "love.graphics",
		FilterMode = "love.graphics",
		Font = "love.graphics",
		GraphicsFeature = "love.graphics",
		GraphicsLimit = "love.graphics",
		Image = "love.graphics",
		LineJoin = "love.graphics",
		LineStyle = "love.graphics",
		MeshDrawMode = "love.graphics",
		Mesh = "love.graphics",
		ParticleInsertMode = "love.graphics",
		ParticleSystem = "love.graphics",
		PointStyle = "love.graphics",
		Quad = "love.graphics",
		Shader = "love.graphics",
		SpriteBatch = "love.graphics",
		SpriteBatchUsage = "love.graphics",
		StackType = "love.graphics",
		StencilAction = "love.graphics",
		Text = "love.graphics",
		Texture = "love.graphics",
		Video = "love.graphics",
		WrapMode = "love.graphics",
		CompressedImageData = "love.image",
		CompressedImageFormat = "love.image",
		ImageData = "love.image",
		ImageFormat = "love.image",
		GamepadAxis = "love.joystick",
		GamepadButton = "love.joystick",
		JoystickHat = "love.joystick",
		Joystick = "love.joystick", -- FIXME
		JoystickInputType = "love.joystick",
		KeyConstant = "love.keyboard",
		Scancode = "love.keyboard",
		BezierCurve = "love.math",
		CompressedDataFormat = "love.math",
		CompressedData = "love.math",
		RandomGenerator = "love.math",
		Cursor = "love.mouse",
		CursorType = "love.mouse",
		Body = "love.physics",
		BodyType = "love.physics",
		ChainShape = "love.physics",
		CircleShape = "love.physics",
		Contact = "love.physics",
		DistanceJoint = "love.physics",
		EdgeShape = "love.physics",
		Fixture = "love.physics",
		FrictionJoint = "love.physics",
		GearJoint = "love.physics",
		Joint = "love.physics",
		JointType = "love.physics",
		MotorJoint = "love.physics",
		MouseJoint = "love.physics",
		PolygonShape = "love.physics",
		PrismaticJoint = "love.physics",
		PulleyJoint = "love.physics",
		RevoluteJoint = "love.physics",
		RopeJoint = "love.physics",
		Shape = "love.physics",
		ShapeType = "love.physics",
		WeldJoint = "love.physics",
		WheelJoint = "love.physics",
		World = "love.physics",
		Decoder = "love.sound",
		SoundData = "love.sound",
		PowerState = "love.system",
		Channel = "love.thread",
		Thread = "love.thread", -- FIXME
		VideoStream = "love.video",
		FullscreenType = "love.window",
		MessageBoxType = "love.window",
	}

	-- types: { name -> true }
	function resolveImports(types, package)
		local imports = {}
		for i, v in pairs(types) do
			local module = lovetypes[i]
			if module and module ~= package then
				table.insert(imports, ("import %s.%s;"):format(module, i))
			end
		end
		table.sort(imports)
		return table.concat(imports, "\n")
	end
end

do -- YET ANOTHER UGLY HACK
	local typeOrder = 
	{
		"Object",
		"Data",
		"Drawable",
		"Texture",
		"Shape",
		"Joint",
	}

	local function find(t, value)
		for i, v in ipairs(t) do
			if v == value then return i end
		end
		print("Unknown supertype: ", value)
	end

	function mostSpecificSupertype(t)
		local maxVal, maxPos = "UserData", 0
		for i, v in ipairs(t) do
			local pos = find(typeOrder, v)
			if pos and pos > maxPos then
				maxVal, maxPos = v, pos
			end
		end
		return maxVal
	end
end

do
	local map =
	{
		number = "Float",
		string = "String",
		boolean = "Bool",
		table = "Table<Dynamic,Dynamic>",
		["light userdata"] = "UserData",
		userdata = "UserData",
		["function"] = "Dynamic", -- FIXME
		mixed = "Dynamic",
		value = "Dynamic",
		any = "Dynamic",

		-- FIXME
		["ShaderVariableType"] = "String",
		["KeyConstant"] = "String",
		["Scancode"] = "String",
	}
	
	function typeMap(t)
		return map[t] or t
	end
end

function capitalize(s)
	return s:sub(1, 1):upper() .. s:sub(2)
end

function mergeTables(target, src, prefix)
	prefix = prefix or ""
	for i, v in pairs(src) do
		target[prefix .. i] = v
	end
	return target
end

function dirname(path)
	return path:match("^(.-)/?[^/]+$")
end

function emitOverload(o, types)
	local args = {}
	for i, v in ipairs(o.arguments or {}) do
		v.type = typeMap(v.type)
		types[v.type] = true

		if v.name == "..." then
			table.insert(args, ("args:Rest<%s>"):format(v.type))
		else
			local arg = (v.default and "?" or "") .. v.name .. ":" .. v.type
			table.insert(args, arg)
		end
	end
	local retType = "Void"
	if o.returns then -- TODO: multiple returns
		retType = typeMap(o.returns[1].type)
		types[retType] = true
	end
	return ("(%s) : %s"):format(table.concat(args, ", "), retType)
end

function emitCallback(c, types)
	local type = {}
	for i, v in ipairs(c.variants[1].arguments or {}) do -- TODO: Multiple variants? Does that even exist?
		table.insert(type, typeMap(v.type))
		types[type[#type]] = true
	end

	if c.variants[1].returns then -- TODO: Multiple returns?
		table.insert(type, typeMap(c.variants[1].returns[1].type))
		types[type[#type]] = true
	else
		table.insert(type, "Void")
	end

	-- If there are no arguments, prepend Void
	if #type == 1 then
		table.insert(type, 1, "Void")
	end

	type = table.concat(type, "->")

	return ("\tpublic static var %s : %s;"):format(c.name, type)
end

function rawEmitFunction(f, types, static)
	local out = {""}

	local sigs = {}
	for i, v in ipairs(f.variants) do
		table.insert(sigs, emitOverload(v, types))
	end

	local main = table.remove(sigs, 1)
	for i, v in ipairs(sigs) do
		table.insert(out, ("\t@:overload(function %s {})"):format(v))
	end
	table.insert(out, ("\tpublic%s function %s%s;"):format(static and " static" or "", f.name, main))
	return table.concat(out, "\n")
end

function emitFunction(f, types)
	return rawEmitFunction(f, types, true)
end

function emitMethod(m, types)
	return rawEmitFunction(m, types, false)
end

function emitEnum(e, packageName)
	local out = {}
	table.insert(out, ("package %s;"):format(packageName))
	table.insert(out, "@:enum")
	table.insert(out, ("abstract %s (String)\n{"):format(e.name))

	for i, v in ipairs(e.constants) do
		table.insert(out, ("\tvar %s = \"%s\";"):format(capitalize(v.name), v.name))
	end

	table.insert(out, "}")
	return {[e.name .. ".hx"] = table.concat(out, "\n")}
end

function emitHeader(out, packageName)
	table.insert(out, ("package %s;"):format(packageName))
	table.insert(out, "import haxe.extern.Rest;")
	table.insert(out, "import lua.Table;")
	table.insert(out, "import lua.UserData;")
	table.insert(out, "")
end

function emitType(t, packageName)
	local out = {}
	local types = {}
	emitHeader(out, packageName)

	local superType = t.supertypes and mostSpecificSupertype(t.supertypes) or "UserData"
	table.insert(out, ("extern class %s extends %s\n{"):format(t.name, superType))

	for i, v in ipairs(t.functions or {}) do
		table.insert(out, emitMethod(v, types))
	end

	table.insert(out, "}")
	table.insert(out, 2, resolveImports(types, packageName))
	return {[t.name .. ".hx"] = table.concat(out, "\n")}
end

function emitModule(m, luaName)
	local out = {}
	local files = {}
	local types = {}

	local moduleName = luaName or "love." .. m.name
	local prefix = moduleName:gsub("%.", "/") .. "/"
	emitHeader(out, moduleName)
	table.insert(out, ("@:native(\"%s\")"):format(moduleName))
	table.insert(out, ("extern class %s"):format(capitalize(luaName or m.name)))
	table.insert(out, "{")

	for i, v in ipairs(m.functions) do
		table.insert(out, emitFunction(v, types))
	end

	for i, v in ipairs(m.callbacks or {}) do
		table.insert(out, emitCallback(v, types))
	end

	table.insert(out, "}")

	for i, v in ipairs(m.enums or {}) do
		mergeTables(files, emitEnum(v, moduleName), prefix)
	end

	for i, v in ipairs(m.types or {}) do
		mergeTables(files, emitType(v, moduleName), prefix)
	end

	table.insert(out, 2, resolveImports(types, moduleName))
	files[prefix .. capitalize(luaName or m.name) .. ".hx"] = table.concat(out, "\n")
	return files
end

local files = {}

for i, v in ipairs(api.modules) do
	mergeTables(files, emitModule(v))
end

mergeTables(files, emitModule(api, "love"))

for i, v in pairs(files) do
	os.execute("mkdir -p " .. dirname(i))
	local f = io.open(i, "w")
	f:write(v)
	f:close()
end
